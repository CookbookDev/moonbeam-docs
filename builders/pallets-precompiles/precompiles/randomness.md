---
title: Interacting with the Randomness Precompile
description: Learn about the sources of VRF randomness on Moonbeam and how to use the randomness precompile and consumer interface to generate on-chain randomness.
keywords: solidity, ethereum, randomness, VRF, moonbeam, precompiled, contracts
---

# Interacting with the Randomness Precompile

![Randomness Moonbeam Banner](/images/builders/pallets-precompiles/precompiles/randomness/randomness-banner.png)

## Introduction {: #introduction } 

Randomness is necessary for a variety of blockchain applications to create unbiased, unpredictable, and unique outcomes. However, obtaining a reliable source of randomness is a challenge. Computers are deterministic, meaning given the same input, the same output will always be produced. Therefore, random values generated by computers are referred to as pseudo-random as they appear to be statistically random, but given the same input, the output can easily be repeated. 

Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly.

There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: [local VRF](#local-vrf) and [BABE epoch randomness](#babe-epoch-randomness). Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, [BABE](https://wiki.polkadot.network/docs/learn-consensus#block-production-babe){target=_blank} epoch randomness is based on all the VRF produced by the relay chain validators during a complete [epoch](https://wiki.polkadot.network/docs/glossary#epoch){target=_blank}.

Moonbeam provides a randomness precompile, which is a Solidity interface that enables smart contract developers to generate randomness via local VRF or BABE epoch randomness using the Ethereum API.

The randomness precompile is currently only available on Moonbase Alpha and is located at the following address:

=== "Moonbase Alpha"
     ```
     {{ networks.moonbase.precompiles.randomness }}
     ```

## The Randomness Solidity Interface {: #the-randomness-interface }

[Randomness.sol](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L4-L11){target=_blank} is a Solidity interface that allows developers to interact with the precompile's methods.

The interface includes constants, events, enums, and functions as covered in the following sections.

### Functions {: #functions }

The interface includes the following functions:

- **relayEpochIndex**() — returns the current relay epoch index, where an epoch represents real time and not a block number
- **requiredDeposit**() — returns the deposit required to perform a randomness request
- **getRequestStatus**(*uint256* requestId) — returns the request status of a given randomness request
- **getRequest**(*uint256* requestId) — returns the request details of a given randomness request
- **requestLocalVRFRandomWords**(*address* refundAddress, *uint256* fee, *uint64* gasLimit, *bytes32* salt, *uint8* numWords, *uint64* delay) — request random words generated from the parachain VRF
- **requestRelayBabeEpochRandomWords**(*address* refundAddress, *uint256* fee, *uint64* gasLimit, *bytes32* salt, *uint8* numWords) — request random words generated from the relay chain BABE consensus 
- **fulfillRequest**(*uint256* requestId) — fulfill the request which will call the consumer contract method [`fulfillRandomWords`](#:~:text=rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords)). Fees of the caller are refunded if the request is fulfillable
- **increaseRequestFee**(*uint256* requestId, *uint256* feeIncrease) — increases the fee associated with a given randomness request. This is needed if the gas price increases significantly before the request is fulfilled
- **purgeExpiredRequest**(*uint256* requestId) — removes a given expired request from storage and transfers the request fees to the caller and the deposit back to the 

Where the inputs that need to be provided can be defined as:

- **requestId** - the ID of the randomness request
- **refundAddress** - the address receiving the left-over fees after the fulfillment
- **fee** - the amount to set aside to pay for the fulfillment
- **gasLimit** - the gas limit to use for the fulfillment
- **salt** - a string that is mixed with the randomness seed to obtain different random words
- **numWords** - the number of random words requested, up to the maximum number of random words
- **delay** - the number of blocks that must pass before the request can be fulfilled. This value will need to be between the minimum and maximum number of blocks before a local VRF request can be fulfilled
- **feeIncrease** - the amount to increase fees by

### Constants {: #constants }

The interface includes the following constants:

- **MAX_RANDOM_WORDS** - the maximum number of random words being requested. Set to {{ networks.moonbase.randomness.max_random_words }} words
- **MIN_VRF_BLOCKS_DELAY** - the minimum number of blocks before a request can be fulfilled for local VRF requests. Set to {{ networks.moonbase.randomness.min_vrf_blocks_delay }} blocks
- **MAX_VRF_BLOCKS_DELAY** - the maximum number of blocks before a request can be fulfilled for local VRF requests. Set to {{ networks.moonbase.randomness.max_vrf_blocks_delay }} blocks
- **REQUEST_DEPOSIT_AMOUNT** - the deposit amount needed to request random words. There is one deposit per request. Set to {{ networks.moonbase.randomness.req_deposit_amount }} Wei

### Events {: #events }

The interface includes the following events:

- **FulfillmentSucceeded**() - emitted when the request has been successfully executed
- **FulfillmentFailed**() - emitted when the request has failed to execute fulfillment

### Enums {: #enums }

The interface includes the following enums:

- **RequestStatus** - the status of the request, which can be `DoesNotExist` (0), `Pending` (1), `Ready` (2), or `Expired` (3)
- **RandomnessSource** - the type of the randomness source, which can be `LocalVRF` (0) or `RelayBabeEpoch` (1)

## The Randomness Consumer Solidity Interface {: #randomness-consumer-solidity-interface }

The [`RandomnessConsumer.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/precompiles/randomness/RandomnessConsumer.sol){target=_blank} Solidity interface makes it easy for smart contracts to interact with the randomness precompile. Using the randomness consumer ensures the fulfillment comes from the randomness precompile. 

The consumer interface includes the following functions:

- **fulfillRandomWords**(*uint256* requestId, *uint256[] memory* randomWords) - handles the VRF response for  given request. This method is triggered by a call to `rawFulfillRandomWords`
- **rawFulfillRandomWords**(*uint256* requestId, *uint256[] memory* randomWords) - executed when the [`fulfillRequest` function](#:~:text=fulfillRequest(uint256 requestId)) of the randomness precompile is called. The origin of the call is validated, ensuring the randomness precompile is the origin, and then the `fulfillRandomWords` method is called

## Local VRF {: #local-vrf }

Local VRF randomness is generated on a block-by-block basis at the beginning of the block using the previous block's VRF output along with the public key of the current block author's VRF key. The generated randomness result is stored and used to fulfill all randomness requests for the current block.

If your contract could have concurrent requests open, you can use the `requestId` returned from the `requestLocalVRFRandomWords` method to track which response is associated with which randomness request.

## BABE Epoch Randomness {: #babe-epoch-randomness }

BABE epoch randomness is based on a hash of the VRF values from the blocks produced in the relay chain epoch before last. On Polkadot, an [epoch lasts for roughly 4 hours](https://wiki.polkadot.network/docs/maintain-polkadot-parameters#periods-of-common-actions-and-attributes){target=_blank}, and on Kusama, an [epoch lasts for roughly 1 hour](https://guide.kusama.network/docs/kusama-parameters/#periods-of-common-actions-and-attributes){target=_blank}. The hashing is completed on the relay chain, and as such, it is not possible for a collator on Moonbeam to influence the randomness value unless they are also a validator on the relay chain and were responsible for producing the last output included in an epoch.

The randomness is constant during a full epoch, so if a collator skips block production, the next collator can fulfill it with the same random value. In order to generate unique randomness, a different salt must be provided to the `requestRelayBabeEpochRandomWords` function.

At the beginning of each relay chain epoch change, the randomness from one epoch ago is read from the relay chain state proof and used to fulfill all randomness requests that are due in the current block.

## Request & Fulfill Process {: #request-and-fulfill-process }

To consume randomness, you must have a contract that inherits from the `RandomnessConsumer.sol` interface and imports the `Randomness.sol` precompile. 

Your contract should be able to request randomness through the precompile's `requestLocalVRFRandomWords` method or `requestRelayBabeEpochRandomWords` method depending on the source of randomness you want to use. 

Your contract should also have a `fulfillRandomWords` method with the same [signature as the `fulfillRandomWords` method](#randomness-consumer-solidity-interface) of the `RandomnessConsumer.sol` contract.

When randomness is requested through the precompile's `requestLocalVRFRandomWords` or `requestRelayBabeEpochRandomWords` method, a fee is set aside to pay for the fulfillment of the request. When using local VRF, to increase unpredictability, a specified delay period in blocks, must pass before the request can be fulfilled. At the very least, the delay period must be greater than one block. For BABE epoch randomness, you do not need to specify a delay but can fulfill the request at the beginning of the 2nd epoch following the current one.

After the delay, fulfillment of the request can be manually executed by anyone through the `fulfillRequest` method using the fee that was initially set aside for the request.

When fulfilling the randomness request via the precompile's `fulfillRequest` method, the `rawFulfillRandomWords` function in the `RandomnessConsumer.sol` contract will be called, which will verify that the sender is the randomness precompile. From there, `fulfillRandomWords` is called and the requested number of random words are computed using the current block's randomness result and a given salt and returned. If the fulfillment was successful, the `FulfillmentSucceeded` event will be emitted; otherwise the `FulfillmentFailed` event will be emitted. 

For fulfilled requests, the cost of execution will be refunded from the request fee to the caller of `fulfillRequest`. Then any excess fees and the request deposit are transferred to the specified refund address.

Your contract's `fulfillRandomWords` callback is responsible for handling the fulfillment. For example, in a lottery contract, the callback would use the random words to choose a winner and payout the winnings.

If a request expires it can be purged through the precompile's `purgeExpiredRequest` function. When this function is called the request fee is paid out to the caller and the deposit will be returned to the original requester.

## Security Considerations {: #security-considerations }

A method with the ability to call your `fulfillRandomness` method directly could spoof a VRF response with any random value, so it's critical that it can only be directly called by the `RandomnessConsumer.sol` contract's `rawFulfillRandomness` method.

For your users to trust that your contract's random behavior is free from malicious interference, it's best if you can write it so that all behaviors implied by a VRF response are executed *during* your `fulfillRandomness` method. If your contract must store the response (or anything derived from it) and use it later, you must ensure that any user-significant behavior which depends on that stored value cannot be manipulated by a subsequent VRF request.

Similarly, the collators have some influence over the order in which VRF responses appear on the blockchain, so if your contract could have multiple VRF requests in flight simultaneously, you must ensure that the order in which the VRF responses arrive cannot be used to manipulate your contract's user-significant behavior.

Since the output of the random words generated for `requestLocalVRFRandomWords` is dependent on the collator producing the block at fulfillment, the collator could skip its block, forcing the fulfillment to be executed by a different collator and therefore generating a different VRF. However, such an attack would incur the cost of losing the block reward to the collator. It is also possible for a collator to be able to predict some of the possible outcome of the VRF if the delay between the request and the fulfillment is too short. It is for this reason that you can choose to provide a higher delay.

Since the output of the random words generated for `requestRelayBabeEpochRandomWords` is dependent on the relay chain validator producing the blocks during an epoch, it is possible for the last validator of an epoch to choose between two possible VRF outputs by skipping the production of a block. However, such an attack would incur the cost of losing the block reward to the validator. It is not possible for a parachain collator to predict or influence the output of the relay chain VRF, not to censor the fulfillment, as long as there is one honest collator.

## Interact with the Solidity Interfaces {: #interact-with-the-solidity-interfaces }

### Checking Prerequisites {: #checking-prerequisites } 

In this tutorial, you'll interact with a lottery contract that requires you to have multiple accounts which you can use to participate in a lottery. The default contract sets the minimum number of participants to three, however you can feel free to change the number in the contract. 

Assuming you use the default contract, you will need to have the following:

- [MetaMask installed and connected to Moonbase Alpha](/tokens/connect/metamask/){target=_blank}
- Create or have three accounts on Moonbase Alpha to test out the lottery contract
- All of the accounts will need to be funded with `DEV` tokens.
 --8<-- 'text/faucet/faucet-list-item.md'

### Example Lottery Contract {: #example-contract }

In this tutorial, you'll interact with a lottery contract that uses the randomness precompile and consumer. You'll be generating random words which will be used to select the winner of the lottery fairly. You can find a copy of the lottery contract that will be used for this tutorial, [`RandomnessLotteryDemo.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/tests/contracts/solidity/RandomnessLotteryDemo.sol){target=_blank}, in the Moonbeam GitHub repository.

The lottery contract imports the `Randomness.sol` precompile and the `RandomnessConsumer.sol` interface, and inherits from the consumer contract. In the constructor of the contract, you can specify the source of randomness to be either local VRF or BABE epoch randomness.

In general, the lottery contract includes functionality to check the status of the randomness request which will be used to determine whether the lottery is still accepting participants, if it has started, or if it has expired. It will use the `requestLocalVRFRandomWords` or `requestRelayBabeEpochRandomWords` function to select the random words, depending on which source of randomness you want to use. In addition, it will implement the `fulfillRandomWords` method and the callback will fulfill the request and use the random words to randomly pick the lottery winners.

There are also some constants in the contract that can be edited as you see fit, especially the `SALT_PREFIX` which can be used to produce unique results.

### Remix Set Up {: #remix-set-up } 

You can interact with the randomness precompile and consumer using [Remix](https://remix.ethereum.org/){target=_blank}. To add the interfaces to Remix and follow along with the tutorial, you will need to:

1. Get a copy of [`Randomness.sol`](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol){target=_blank}
2. Paste the file contents into a Remix file named **Randomness.sol**
3. Get a copy of [`RandomnessConsumer.sol`](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol){target=_blank}
4. Paste the file contents into a Remix file named **RandomnessConsumer.sol**
5. Get a copy of [`RandomnessLotteryDemo.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/tests/contracts/solidity/RandomnessLotteryDemo.sol){target=_blank}
6. Paste the file contents into a Remix file named **RandomnessLotteryDemo.sol**

![Add contracts to Remix](/images/builders/pallets-precompiles/precompiles/randomness/randomness-1.png)

You'll need to update the import paths in the `RandomnessLotteryDemo.sol` file to:

```
import "Randomness.sol";
import "RandomnessConsumer.sol";
```

For this example, you can change the `PARTICIPATION_FEE` to a lower amount, such as `100000 gwei`, to maximize the amount of DEV tokens you received from the faucet.

### Compile & Access the Randomness Precompile {: #compile-randomness }

Next, you will need to compile the `Randomness.sol` file in Remix. To get started, make sure you have the **Randomness.sol** file open and take the following steps:

1. Click on the **Compile** tab, second from top
2. To compile the contract, click on **Compile Randomness.sol**

![Compiling Randomness.sol](/images/builders/pallets-precompiles/precompiles/randomness/randomness-2.png)

If the contract was compiled successfully, you will see a green checkmark next to the **Compile** tab.

Instead of deploying the randomness precompile, you will access the interface given the address of the precompiled contract:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note the precompiled contract is already deployed
2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. Once selected, you might be prompted by MetaMask to connect your account to Remix
3. Make sure the correct account is displayed under **ACCOUNT**
4. Ensure **Randomness - Randomness.sol** is selected in the **CONTRACT** dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead we are going to provide the address of the precompile in the **At Address** Field
5. Provide the address of the batch precompile: `{{ networks.moonbase.precompiles.randomness }}` and click **At Address**

![Access the address](/images/builders/pallets-precompiles/precompiles/randomness/randomness-3.png)

The **RANDOMNESS** precompile will appear in the list of **Deployed Contracts**. You will use this to fulfill the randomness request made from the lottery contract later on in this tutorial.

### Compile & Deploy the Lottery Contract {: #compile-lottery }

Next, you will need to compile the `RandomnessLotteryDemo.sol` file in Remix:

1. Make sure that you have the **RandomnessLotteryDemo.sol** file open
2. Click on the **Compile** tab, second from top
3. To compile the contract, click on **Compile RandomnessLotteryDemo.sol**

If the contract was compiled successfully, you will see a green checkmark next to the **Compile** tab.

Once the contract has been compiled, you can deploy the contract by taking the following steps:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix
2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. Once selected, you might be prompted by MetaMask to connect your account to Remix
3. Make sure the correct account is displayed under **ACCOUNT**
4. You'll need to pay the required deposit for a randomness request. For this contract, the required deposit is {{ networks.moonbase.randomness.req_deposit_amount }} Wei. So set the value to `{{ networks.moonbase.randomness.req_deposit_amount }}` and choose **Wei** from the dropdown on the right
5. Ensure **RandomnessLotteryDemo - RandomnessLotteryDemo.sol** is selected in the **CONTRACT** dropdown
6. Next to **Deploy** enter the source of randomness. This corresponds to the [`RandomnessSource`](#enums) enum. For local VRF, enter `0`, and for BABE epoch randomness, enter `1`. To follow along with this example, you can select `0` and click **Deploy**
7. Confirm the MetaMask transaction that appears by clicking **Confirm**

![Deploy RandomnessLotteryDemo](/images/builders/pallets-precompiles/precompiles/randomness/randomness-4.png)

The **RANDOMNESSLOTTERYDEMO** contract will appear in the list of **Deployed Contracts**.

### Participate in the Lottery {: #participate-in-lottery }

The default contract has a minimum requirement of three participants. To participate you can take the following steps:

1. Make sure you've switched to the account you want to participate with in MetaMask. You can verify the account that is connected under **ACCOUNT** 
2. Enter the amount you want to contribute to the lottery in the **VALUE** field. It must be greater than or equal to the `PARTICIPATION_FEE` which should be set to `100000 gwei` in the contract
3. Click on **participate**
4. Confirm the transaction in MetaMask

![Participate in the lottery](/images/builders/pallets-precompiles/precompiles/randomness/randomness-5.png)

Since there is a minimum of three participants required to start the lottery, you'll need to repeat these steps until you've participated from three different accounts.

### Start the Lottery {: #start-the-lottery }

If you take a closer look at the `RandomnessLotteryDemo.sol` contract's `startLottery` function, you'll notice that it has the `onlyOwner` modifier. As such, you will need to make sure that you switch back to the account that deployed the lottery contract before starting the lottery.

To start the lottery and submit the randomness request, which will call the precompile's `requestLocalVRFRandomWords`, you can take the following steps:

1. Confirm the account is the owner
2. To start the lottery you need to pay a fee which will be used to fulfill the randomness request. You can set the **VALUE** to `100000` and choose **Gwei**. The excess fee will be returned to the `msg.sender`
3. Click on **startLottery**
4. Confirm the transaction in MetaMask

![Start the lottery](/images/builders/pallets-precompiles/precompiles/randomness/randomness-6.png)

Once the transaction goes through, the lottery will start and no more participants will be able to join. Before you can fulfill the randomness request in order to pick the winners, you'll need to wait the delay. The default `VRF_BLOCKS_DELAY` is set to `2` blocks.

### Pick the Winners {: #pick-the-winners }

To fulfill the request, you can do so using the `fulfillRequest` function of the randomness precompile, passing in the request ID. The request will be fulfilled and generate the random words and execute the `fulfillRandomWords` function defined in the `RandomnessLotteryDemo.sol` contract. The `fulfillRandomWords` function callback then calls `pickWinners` and the jackpot is distributed to the randomly selected winners.

To get the request ID, you can click on the **requestId** button and the ID will appear under the function.

![Get the request ID](/images/builders/pallets-precompiles/precompiles/randomness/randomness-7.png)

You can initiate the fulfillment from any account after the delay has passed, to do so you'll need to:

1. Expand the **RANDOMNESS** contract
2. For the **fulfillRequest** function, enter the **requestId**
3. Click on **transact**
4. Confirm the transaction in MetaMask

![Fulfill the randomness request](/images/builders/pallets-precompiles/precompiles/randomness/randomness-8.png)

If the transaction reverts with the following error you may need to call `increaseRequestFee`:

```
{ 
  "code": -32603,
  "message": "VM Exception while processing transaction: revert",
  "data": "0x476173206c696d69742061742063757272656e74207072696365206d757374206265206c657373207468616e206665657320616c6c6f74746564"
}
```

The `data` field converted to ASCII text reads: `Gas limit at current price must be less than fees allotted`. As such, you can use the `increaseRequestFee` function to increase the fees for the transaction and try again.

Once the transaction goes through, you can search for the contract's address on [Moonscan](https://moonbase.moonscan.io){target=_blank} and look under the **Events** tab to see the events that were emitted. You should see three events: one `Ended` event and two `Awarded` events.

- **`Ended`** - event sent when the lottery ends, which emits the number of participants, the jackpot, and the total winners. Defined in the `RandomnessLotteryDemo.sol` contract
- **`Awarded`** - event sent when a winner is awarded, which should get emitted twice since there are two winners per the default contract. It emits the winner, the random word, and the amount won. Defined in the `RandomnessLotteryDemo.sol` contract

You can expand each of the events to obtain more information.

![Fulfill the randomness request](/images/builders/pallets-precompiles/precompiles/randomness/randomness-9.png)

Congratulations! You've successfully used the randomness precompile and consumer to participate in and start a lottery, and use the generated random words to select a winner.